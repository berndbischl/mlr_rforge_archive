# generates an R function that we can pass to a tuner to optrimize hyper parsmakeTunerTargetFun = function(learner, task, resampling, measures, par.set, control, opt.path, log.fun, arg.as.list, trafo) {  function(p) {    pars = par.set$pars    # are arguments already in form of a list or do we get them as a vector?    if (arg.as.list) {      p.split = p    } else {      ids = getParamIds(par.set, repeated=TRUE, with.nr=FALSE)      # factor usually does sort(unique(...)) for levels which changes order!       p.split = split(p, factor(ids, levels=unique(ids)))    }    # make sure to round all integer parameters    p.split = Map(function(par, x) {         if (par$type %in% c("integer", "integervector"))          as.integer(round(x))        else          x      },       pars, p.split    )    # transform parameters    p.split2 = if (trafo) trafoValue(par.set, p.split) else p.split    y = evalOptimizationState(learner, task, resampling, measures, par.set, NULL, control, opt.path, log.fun, p.split2)     addOptPathEl(opt.path, x=p.split, y=y)      ifelse(measures[[1]]@minimize, 1 , -1) * y[1]  }  }