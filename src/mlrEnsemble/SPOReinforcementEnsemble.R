#' @exportClass SPOReinforcementEnsemblesetClass(  "SPOReinforcementEnsemble",     contains = c("BaseCombiner"),  representation = representation(    prefs = "matrix",    probs = "matrix",    improvements = "numeric",    rewards = "numeric",    ref.reward = "numeric",    sel.learners = "integer",    control = "list"  ))   #' Constructor.setMethod(  f = "initialize",  signature = signature("SPOReinforcementEnsemble"),  def = function(.Object, base.learners, control) {    .Object@control = control    n = length(base.learners)    .Object@probs = matrix(rep(1/n, n), nrow=1, ncol=n)    callNextMethod(.Object, learners=base.learners, par.set=makeParamSet())  })setGeneric(  name = "makeSPOReinforcementEnsemble",  def = function(id, base.learners, control) {    if(missing(id))      id = "SPOReinforcementEnsemble"    standardGeneric("makeSPOReinforcementEnsemble")  })#' @rdname makeSPOReinforcementEnsemblesetMethod(  f = "makeSPOReinforcementEnsemble",    signature = signature(    id="character",     base.learners="list",     control="list"   ),    def =  function(id, base.learners, control) {    #todo: check that base.learners and super.learner types match    checkListElementClass(base.learners, "Learner")    types = unique(sapply(base.learners, function(x) x@properties$type))    if (types != "regr")      stop("Base learners must all have the type 'regr'!")    w = new("SPOReinforcementEnsemble", base.learners, control)    w@properties$type = types    w@properties["numerics"] = all(sapply(base.learners, function(x) x@properties$numerics))    w@properties["factors"] = all(sapply(base.learners, function(x) x@properties$factors))    w@properties["weights"] = all(sapply(base.learners, function(x) x@properties$weights))    w@properties["missings"] = all(sapply(base.learners, function(x) x@properties$missings))    w@id = id    return(w)  })#' @rdname trainLearnersetMethod(  f = "trainLearner",  signature = signature(    .learner="SPOReinforcementEnsemble",     .task="LearnTask", .subset="integer"  ),    def = function(.learner, .task, .subset,  ...) {    tn = .task@desc@target    learners = .learner@learners     ids = sapply(learners, function(x) x@id)    if (tn %in% ids)       stop("Learner id is equal to target name of task!")    .task = subsetData(.task, subset=.subset)      probs = .learner@probs    probs = probs[nrow(probs),]    j = sample(1:length(learners), 1, prob=probs)    sel.lrn = learners[[j]]		model <- train(sel.lrn, .task)    return(model)  })#' @rdname predictLearnersetMethod(  f = "predictLearner",  signature = signature(    .learner = "SPOReinforcementEnsemble",     .model = "WrappedModel",     .newdata = "data.frame",     .type = "missing"   ),    def = function(.learner, .model, .newdata, .type, ...) {    m = .model@learner.model    predictLearner(m@learner, m, .newdata, ...)  })   #todo: print methodinitAfterInitDesign = function(learner, des, y) {  # init stuff here, e.g. by resampled rmse or whatever  learner}updateAfterStep = function(learner, model, x, y.true, y.pred, opt.path, y.name) {  ctrl = learner@control  sel.learner = 999  n = length(improvements) + 1  y.prev.min = min(getYVector(opt.path, y.name))  learner@improvements[n] = y.prev.min - y.true  learner@rewards[n] = improvementToReward(learner@improvements[n])  learner@ref.rewards[n] = learner@ref.rewards[n-1] + ctrl$alpha*    (learner@rewards[n] - learner@ref.rewards[n-1])  prefs = learner@prefs[n-1,]    prefs[sel.learner] = prefs[sel.learner] + ctrl$beta*(learner@rewards[n] - learner@ref.rewards[n])  if (ctrl$prob.method=="gibbs")    probs = gibbs(prefs)  else if (ctrl$prob.method=="linear")    probs = lineartransf(prefs)  learner@pref = rbind(learner@prefs, prefs)  learner@probs = rbind(learner@probs, probs)  learner}