<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
	<title>Tuning</title>
	<link rel="stylesheet" type="text/css" href="formats.css">
	<style type="text/css">
	</style>
</head>

<body>
<h1>Tuning of hyperparameters</h1>


<P>Many classification algorithms feature a set of hyperparameters that either need 
to be selected by the user or through resampling, e.g. cross-validation. Setting them 
by hand was already covered in the section about <a href="train.html">Training </a> and <a href="resampling.html">Resampling </a> - simply use the 
"parset" argument in the <a href="rdocs/train.html">"train"</a> or <a href="rdocs/resample.fit.html">"resample.fit"</a> methods</P>

<P>Assuming, you have understood how <a href="resampling.html">resampling</a> works,  
it is quite simple to implement a grid search, which is one of the standard - albeit slow - ways 
to choose an appropriate set of parameters from a given range of values.</P> 

<p><img src="pics/tune_varsel processing.png" width="40%"  border="1" alt=""></p>



<h3>Classification example</h3>

<P>We again use the iris data set and now want to tune a SVM with a polynomial kernel.</P>

<pre>
	<com># Classification task</com>
	ct <- make.task(data = iris, target = "Species")

	<com># Range of the values</com>
	r <- list(C = 2^(-1:1), sigma = 2^(-1:1))

	<com># Evaluation with 3-fold cross-validation</com>
	res <- make.res.desc("cv", iters = 3)

	<com># Tune SVM</com>
	tune("classif.ksvm", ct, res, grid.control(ranges = r))
	<res>
	Optimization result: 
	$C
	[1] 1
	
	$sigma
	[1] 0.5
	
	 mean.mmce    sd.mmce 
	0.04666667 0.04163332 
	</res>
</pre>

<P>Let's take a look at the above code.</P>

<P>The parameter grid has to be a named list, where every entry has 
to be named according to the corresponding parameter of the underlying R function 
(in this case "ksvm" from the kernlab package, see its respective help page). 
Its value is a vector of feasible values for this hyperparameter. The complete grid is just 
the cross-product of all feasible values. </P>
(Please note that with ksvm we encounter a somewhat special case, as the parameters 
should be passed through the "kernel" and "kpar" structures. 
To make this simpler, t.svm allows direct passing. Again, see documentation.) <P>
Tune now simply performs the cross-validation for every element of the cross-product and selects 
the one with the best mean performance measure.</P> 

<br>
<P>SVMs exhibit another special case with regard to tuning, as one generally does not want 
to optimize over a complete cross-product, when using different kernels with different kernel 
parameters. mlr therefore allows "ranges" to be a list of ranges: <br>
Let's tune SVMs with polynomial and gaussian kernels on iris</P>

<pre>
	<com># Classification task</com>
	ct <- make.task(data = iris, target = "Species")

	<com># Different kernels with different kernel parameters </com>
	r1 <- list(C = c(0.5, 1, 2), kernel = "polydot", degree = 1:3)
	r2 <- list(C = c(0.5, 1, 2), kernel = "rbfdot", sigma = c(0.1, 0.2, 0.3))

	<com># Evaluation with 5-fold cross-validation</com>
	res <- make.res.desc("cv", iters = 5)
	
	<com># Combine grids</com>
	r <- list(r1, r2)

	<com># Tune SVMs</com>
	tune("classif.ksvm", ct, res, grid.control(ranges = r)) 
	<res>
	Optimization result: 
	[[1]]
	[[1]]$C
	[1] 0.5 1.0 2.0
	
	
	[[2]]
	[[2]]$C
	[1] 0.5 1.0 2.0
	
	
	 mean.mmce    sd.mmce 
	0.04000000 0.02788867 
	</res>
</pre>

<h3>Regression example</h3>

<P> Let's tune a k-nearest-neighbor-regression from kknn on the BostonHousing data set. </P>

<pre>
	<com># Regression task</com>
	library(mlbench); data(BostonHousing)
	rt <- make.task(data = BostonHousing, target = "medv")

	<com># Range of the value k </com>
	range <- list(k = 1:7)

	<com># Evaluate with 5-fold cross-validation</com>
	res <- make.res.desc("cv", iters = 5)
	
	<com># Tune k-nearest-neighbor-regression with mean squared error as default measure</com>
	tune("regr.kknn", rt, res, control = grid.control(ranges = range), measure = "mse")
	<res>
	Optimization result: 
	$k
	[1] 4
	
	 mean.mse    sd.mse 
	15.927590  6.166622 
	</res>
</pre>

</body>
</html>
