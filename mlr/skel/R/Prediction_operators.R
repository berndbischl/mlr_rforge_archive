#'  Convert to data.frame#' @rdname Prediction-class #' @exportas.data.frame.Prediction = function(x, row.names = NULL, optional = FALSE,...) {  return(x$data)}#' Get probabilities for some classes.#' @param pred [\code{\linkS4class{Prediction}}] #'   Prediction object.#' @param class [character] #'   Names of classes. Default is either all classes for multi-class problems or the positive class for binary classification.#' @return Data.frame with numerical columns or a numerical vector if length of \code{class} is 1. #'   Order of columns is defined by \code{class}.#' @exportMethod getProb#' @rdname getProbgetProb = function(pred, class) {  checkArg(pred, "Prediction")  if (pred$task.desc$type != "classif")    stop("Prediction was not generated from a ClassifTask!")  if (missing(class)) {    if (length(pred$task.desc$class.levels) == 2)      class = pred$task.desc$positive    else      class = pred$task.desc$class.levels  }  if (pred$predict.type != "prob")    stop("Probabilities not present in Prediction object!")  cns = colnames(pred$df)  class2 = paste(pred$predict.type, class, sep=".")  if (!all(class2 %in% cns))    stop("Trying to get scores for nonexistant classes:", paste(class, collapse=","))  y = pred$df[, class2]  if (length(class) > 1)    colnames(y) = class  return(y)}#c.Prediction = function(...) {#	preds = list(...)#	id = Reduce(c, lapply(preds, function(x) x@id))#	response = Reduce(c, lapply(preds, function(x) x@response))#	target = Reduce(c, lapply(preds, function(x) x@target))#	weights = Reduce(c, lapply(preds, function(x) x@weights))#	prob = Reduce(rbind, lapply(preds, function(x) x@prob))#	return(new("Prediction", task.desc=preds[[1]]@desc, id=id, response=response, target=target, weights=weights, prob=prob));#}