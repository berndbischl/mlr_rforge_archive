#'  Convert to data.frame#' @rdname Prediction-class #' @exportas.data.frame.Prediction = function(x, row.names = NULL, optional = FALSE,...) {  return(x$data)}#' Get probabilities for some classes.#' @param pred [\code{\link{Prediction}}] #'   Prediction object.#' @param cl [\code{character}] #'   Names of classes. Default is either all classes for multi-class problems or the positive class for binary classification.#' @return Data.frame with numerical columns or a numerical vector if length of \code{cl} is 1. #'   Order of columns is defined by \code{cl}.#' @exportMethod getProb#' @rdname getProbgetProb = function(pred, cl) {  checkArg(pred, "Prediction")  if (pred$task.desc$type != "classif")    stop("Prediction was not generated from a ClassifTask!")  if (missing(cl)) {    if (length(pred$task.desc$class.levels) == 2)      cl = pred$task.desc$positive    else      cl = pred$task.desc$class.levels  }  if (pred$predict.type != "prob")    stop("Probabilities not present in Prediction object!")  cns = colnames(pred$data)  cl2 = paste("prob", cl, sep=".")  if (!all(cl2 %in% cns))    stopf("Trying to get scores for nonexistant classes: %s", collapse(cl))  y = pred$df[, cl2]  if (length(cl) > 1)    colnames(y) = cl  return(y)}#c.Prediction = function(...) {#	preds = list(...)#	id = Reduce(c, lapply(preds, function(x) x@id))#	response = Reduce(c, lapply(preds, function(x) x@response))#	target = Reduce(c, lapply(preds, function(x) x@target))#	weights = Reduce(c, lapply(preds, function(x) x@weights))#	prob = Reduce(rbind, lapply(preds, function(x) x@prob))#	return(new("Prediction", task.desc=preds[[1]]@desc, id=id, response=response, target=target, weights=weights, prob=prob));#}