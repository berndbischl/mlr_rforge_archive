Creating a New Learner
======================

In order to create a new learner in **mlr** you have to write some piece of 
interface code.


package mlr source files
go to  src/mlr/models
two directories classification and regression

three steps

* initialization: set class, parameters, properties
* create the training function/method
* create the predict function/method


Examples of Linear Discriminant Analysis for classification and linear regression


Classification example
----------------------

Initialization
..............

* name of learner, package
* create the parameter set for your learner
* set the properties of your learner

Name your learner,
replace in all parts of the code
The naming conventions in **mlr** are ``classif.<R_method_name>`` for classification and
``regr.<R_method_name>`` for regression. 


parameters, 
complete description,
all possible values for discrete parameters
lower and upper bounds for numeric parameters
link zu parameter sets
makeParameterSet_


properties (see also the Section about Learners_),  setProperties_

* Which types of predictors that are supported? numerics, factors
* Are case weights supported?
* Can the method deal with missing values in the predictor variables? deal with NAs in a meaningful way, not na.omit
* Are oneclass, twoclass, multiclass problems supported?
* Can the learner predict posterior probabilities?

In the following example R-code for Linear Discriminant Analysis.
name is ``"classif.lda"``, package ``MASS``.
LDA has one discrete parameter, ``moment``, and two continuous ones, ``nu`` and ``tol``.
It can deal with numeric and factor explanatory variables. It does not support case weights
and can not cope with missing values in a meaningful way (na.action argument...). It supports
classification problems with two or more classes and predicts posterior probabilities.
 
<<eval=FALSE>>=
setClass(
		"classif.lda", 
		contains = c("rlearner.classif")
)

setMethod(
	f = "initialize",
	signature = signature("classif.lda"),
	def = function(.Object) {
		par.set = makeParameterSet(
			makeDiscreteLearnerParameter(id="method", default="moment", vals=c("moment", "mle", "mve", "t")),
			makeNumericLearnerParameter(id="nu", lower=2, requires=expression(method=="t")),
          	makeNumericLearnerParameter(id="tol", default=1.0e-4, lower=0)
      	)
		.Object = .Object = callNextMethod(.Object, pack="MASS", par.set=par.set)
      	setProperties(.Object, 
        	numerics = TRUE, 
        	factors = TRUE,
        	weights = FALSE,
        	missings = FALSE,
        	oneclass = FALSE,
        	twoclass = TRUE, 
        	multiclass = TRUE, 
        	prob = TRUE
      	)
	}
)
@

All properties are set to ``FALSE`` by default. That is you have only to set the properties whose
values are ``TRUE``. 



Creating the train method
.........................

<<eval=FALSE>>=
setMethod(
	f = "trainLearner",
	signature = signature(
		.learner="classif.lda", 
		.task="ClassifTask", .subset="integer" 
	),
	def = function(.learner, .task, .subset,  ...) {
		f = getFormula(.task)
		lda(f, data=getData(.task, .subset), ...)
	}
)
@

Replace lda by the name of the training function of your method.
Pass all required arguments to the training function. The data can be extracted from the task via 
the getData_ function.
Pass further arguments like case weights to the training method
positive class
slots of the LearnTask_
...?

See also the documentation of trainLearner_.


Creating the predict method
...........................

<<eval=FALSE>>=
setMethod(
	f = "predictLearner",
	signature = signature(
		.learner = "classif.lda", 
		.model = "WrappedModel", 
		.newdata = "data.frame" 
	),
	def = function(.learner, .model, .newdata, ...) {
		p <- predict(.model@learner.model, newdata=.newdata, ...)
		if(.learner@predict.type == "response")
			return(p$class)
		else
			return(p$posterior)
	}
)
@

return class labels or posterior probabilities depending on the predict.type

...?
See also predictLearner_.




Regression example
------------------

Initialization
..............

* name of learner, package
* create the parameter set for your learner
* set the properties of your learner

Name your learner,
replace in all parts of the code
The naming conventions in **mlr** are ``classif.<R_method_name>`` for classification and
``regr.<R_method_name>`` for regression. 


parameters, 
complete description,
all possible values for discrete parameters
lower and upper bounds for numeric parameters
link zu parameter sets
makeParameterSet_


properties (see also the Section about Learners_),  setProperties_

* Which types of predictors that are supported? numerics, factors
* Are case weights supported?
* Can the method deal with missing values in the predictor variables? deal with NAs in a meaningful way, not na.omit


If you had a look at the classification example ... some more properties of a Learner_ can be set.
classification, default to FALSE, i.e. in the regression case you do not have to take care of
these properties.



<<eval=FALSE>>=
setClass(
	"regr.lm", 
	contains = c("rlearner.regr")
)

setMethod(
		f = "initialize",
		signature = signature("regr.lm"),
		def = function(.Object) {
			.Object = callNextMethod(.Object, pack="stats")
      
      setProperties(.Object,
        numerics = TRUE,
        factors = TRUE,
        weights = TRUE,
        missings = FALSE
      )
    }
)
@


Creating the train method
.........................

<<eval=FALSE>>=
setMethod(
		f = "trainLearner",
		signature = signature(
				.learner="regr.lm", 
				.task="RegrTask", .subset="integer" 
		),
		
		def = function(.learner, .task, .subset, ...) {
			f = getFormula(.task)
      d = getData(.task, .subset)
      if (.task@desc@has.weights) {
        # strange bug in lm concerning weights
        do.call(lm, list(f, data=d, weights=.task@weights[.subset]))
      }else  
        lm(f, data=d, ...)
    }
)
@


Creating the predict method
...........................

<<eval=FALSE>>=
setMethod(
		f = "predictLearner",
		signature = signature(
				.learner = "regr.lm", 
				.model = "WrappedModel", 
				.newdata = "data.frame" 
		),
		
		def = function(.learner, .model, .newdata, ...) {
			predict(.model@learner.model, newdata=.newdata, ...)
		}
)	
@



.. _makeParameterSet: ../_static/rdocs/mlr/makeParameterSet.html
.. _setProperties: ../_static/rdocs/mlr/setProperties.html
.. _getData: ../_static/rdocs/mlr/getData.html
.. _Learner: ../_static/rdocs/mlr/Learner-class.html
.. _trainLearner: ../_static/rdocs/mlr/trainLearner-class.html
.. _predictLearner: ../_static/rdocs/mlr/predictLearner-class.html
.. _LearnTask: ../_static/rdocs/mlr/LearnTask-class.html
.. _Learners: ../tutorial/learner.html
